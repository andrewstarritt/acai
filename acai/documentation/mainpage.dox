/**
 */

/** \mainpage

<h2>Introduction</h2>

ACAI (ar-sigh-ee) is the ACAI Channel Access Interface - yes, it's one of those
overused recursive acronyms.

ACAI provides a thin-ish C++ EPICS Channel Access abstraction around the
basic Channel Access API.
This has been developed on and for Linux, but should take minimal effort
to modify the code for other environments.

The main ACAI::Client class was developed fron the struct sCA_Client type
and associated functions defined in pv_client.h/pv_client.c out of the kryten
application.

The Acai (Euterpe oleracea) berry is known to originate from Amazon rainforest
in Brazil.

<h2>License</h2>
ACAI is distributed under the GNU General Public License version 3.

The ACAI library is distributed "AS IS" in the hope that it will be useful, but
is distributed WITHOUT ANY WARRANTY;  without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.


<h2>Using ACAI - Getting started</h2>

First off, you will need to to include the following header files.
Technically you get the first include via the second include, but I like to be
explicit.
<pre>
  \#include <acai_client_types.h>
  \#include <acai_client.h>
</pre>

Next, choose the thread that will interface to ACAI. This can be the main program
thread or any other thread. Within that thread call:
<pre>
  ACAI::Client::initialise();
</pre>

This function's main purpose is to call <i>ca_context_create</i>, but also performs
other functions necessary to use the ACAI.
ACAI does not expose the under-lying EPICS context, but does it provide a means
for other threads to attach to the ACAI context.

NOTE: This version of ACAI does not support multiple contexts is any fashsion
what-so-ever. The initialise, attach, poll and finalise functions described herein
are static functions as opposed to be some kind of context object related methods.

Next create a client object, and open the channel
<pre>
  ACAI::Client pv ("SR11MCM01:CURRENT_MONITOR");
  pv.openChannel();
</pre> or <pre>
  ACAI::Client* pv = new ACAI::Client ("SR11MCM01:CURRENT_MONITOR");
  pv->openChannel();   // remember to delete pv
</pre>

The openChannel function creates a channel and when the connection event occurs
(provided the connection it is a successful) is processed, it then  requests a
channel read (with all meta data) and also subscribes for time-based channel data
updates.

Although ACAI uses EPICS callbacks internally, the callbacks are buffered and must
be processed by calling <i>ACAI::Client::poll</i> from the nominated thread.
When a buffered call back is processed, it updates the status/data/meta data of
the associated client object, and then triggers the ACAI updates and callbacks.
These all occur within the user's own thread.
This avoids the need for any mutex locking when dealing with ACAI objects and/or data.
If that data is passed on to any third party threads, then you will need to manage that.
See notes on multiple threads below.

All ACAI applications must have some sort of event loop.
The event loop should must contain a small delay, very much application dependent,
but typically 20mS to 50mS, e.g.:
<pre>
  <b>while</b> (true) {
     epicsThreadSleep (0.02);  // 20mSec
     ACAI::Client::poll ();    // ACAI call back functions invoked from here
     ...
     ... any other application functionality
     ...
  }
</pre>

If the application provides some means to break out of event loop then the following
should be called to tidyup. This may be particularly important if leaving the event
loop does not occur immediately before the application terminates.
<pre>
   pv.closeChannel();
   ACAI::Client::finalise();
</pre>

The above is fine, but we need to access the PV's data for this program to do
anything useful. ACAI provides a number of ways to gain access to PV data.
These are:

a) within the event loop, just read the data, if available, out of the client object;
<pre>
     <b>if</b> (pv.dataIsAvailable()) {
        double x = pv.getFloating ();
        // do something with x
     }
 

</pre>


b) define and setup a connection and/or data update handler, e.g.
<pre>

  <b>static void</b> dataUpdateEventHandler (ACAI::Client* client, <b>const</b> bool firstupdate)
  {
     double x = client->getFloating ();
     // do something with latest client data
  }

  ...

  pv.setUpdateHandler (dataUpdateEventHandler);


</pre>

c) derive a class based on ACAI::Client and override the ACAI::Client::connectionUpdate
or ACAI::Client::dataUpdate functions;

<pre>
  <b>class</b> MyClient : <b>public</b> ACAI::Client {

     // override base class function
     <b>void</b> dataUpdate (<b>const</b> bool firstUpdate) {
        double x = this->getFloating ();
        // do something with latest client data
     }
  }

  ...

  MyClient pv ("SR11MCM01:CURRENT_MONITOR");


</pre>

d) use an ACAI::Abstract_Client_User class - refer to class documentation.

Note: The various callback and polymorphic notifcation function calls are all executed
in the thread that calls the poll function irrespective of which thread(s)
created the ACAI::Client object and/or called the openChannel function.



<h3>Example</h3>
An example program that brings all the above together has been included in
acaiTestApp/acai_monitor.cpp
The is a simple command line program that use the ACAI framework.
This programs mimics the basic fuctionality of the EPICS base program camonitor.

Note:
This program is intended as example (and test) ACAI program rather than as
replacements for the afore mentioned camonitor program.

<h2>Multiple Threads</h2>
Using the ACAI::Client::attach function, it is possible for other threads to
attach the the ACAI context and then go on to create client objects and perform
operations on the object (openChannel, getInteger etc.). However there <b>is
no internal mutex protection</b> of the state/data of a client object, so it is
the user's responsibility to ensure thread safe operations, particularly with
respect to ACAI::Client_Set objects and hence Abstract_Client_User register/deregister
functions.

Also, as stated, the internal updating of the client object and the callbacks/polymorphic
functions are executed by the thread that calls poll (), so any other thread
reading data from a client object may get inconsistant data; and even where the value
is self consistant (probably okay for short, integer, enum) the associated timestamp and
severity/status data could be from the previous/next update.

So in general, the creation and setup of client objects may be hand-balled off to
another thread, but the general opertation (polling and data extraction) is best
all done on one thread.
If multiple worker threads are needed to process large data sets, then user needs to
extract a copy the data/meta data and pass this to the worker thread for processing.
Just notifying a worker thread that new data is available for a particular object
is <b>not</b> recommended.

<h2>Building/Linking</h2>
An ACAI program, like the above example, may be built using the EPICS make system.
However, as the ACAI header files only call up other ACAI header files the fallowing
external header files:
<pre>
  \#include \<set\>
  \#include \<string\>
  \#include \<vector\>
</pre>
it is easy to build an ACAI application without any reference to EPICS header files.


<h2>Dependancies</h2>
Apart from the EPICS shared libraries ca, Com and their dependancies, ACAI does
not reply on any non-standard libraries and/or templates, thus there are no troublesome
or unexpected dependancies.

*/
