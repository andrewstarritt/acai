/**
 */

/** \mainpage

<h2>Introduction</h2>

ACAI (ar-sigh-ee) is the ACAI Channel Access Interface - yes, it's one of those
overused recursive acronyms.

ACAI provides a thin-ish C++ EPICS Channel Access abstraction around the
basic Channel Access API.
This has been developed on and for Linux, but should take minimal effort
to modify the code for other environments.

The main ACAI::Client class development was based on the struct sCA_Client type
and associated functions defined in pv_client.h/pv_client.c out of the kryten
application.

The Acai (Euterpe oleracea) berry is known to originate from Amazon rainforest
in Brazil.

<h2>License</h2>
ACAI is distributed under the GNU General Public License version 3.

The ACAI library is distributed in the hope that it will be useful, but is
distributed "AS IS" and WITHOUT ANY WARRANTY;  without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.


<h2>Using ACAI - Getting started</h2>

First off, you will need to to include the following header files.
Technically you get the first include via the second include, but I like to be
explicit.
<pre>
  \#include <acai_client_types.h>
  \#include <acai_client.h>
</pre>

Next, choose the thread that will interface to ACAI. This can be the main program
thread or any other thread. Within that thread call:
<pre>
  ACAI::Client::initialise();
</pre>

This function's main purpose is to call <i>ca_context_create</i>.
ACAI does not expose the under-lying EPICS context, nor does it provide a means
for other threads to join/attach to that context.
As the context is created with <i>ca_disable_preemptive_callback</i> additional,
threads are not allowed to join the CA context anyway (as per the 3.14 CAref
manual).

NOTE: This version of ACAI does not support multiple contexts is any fashsion
what-so-ever. The initialise, poll and finalise functions descrined herein are
static functions as opposed to be some hind of context object methods.

Next create a client object, and open the channel
<pre>
  ACAI::Client pv ("SR11MCM01:CURRENT_MONITOR");
  pv.openChannel();
</pre> or <pre>
  ACAI::Client* pv = new ACAI::Client ("SR11MCM01:CURRENT_MONITOR");
  pv->openChannel();   // remember to delete pv
</pre>

The openChannel function creates a channel and when the connection event (provided
the connection it is a successful) is processed, it then  requests a channel read
(with all meta data) and also subscribes for channel data updates.

Although ACAI uses EPICS callbacks internally, the callbacks are buffered and must
be processed by calling <i>ACAI::Client::poll</i> from the nominated thread.
When a buffered call back is processed, it updates the status/data/meta data of
the associated client object, and then triggers the ACAI updates and callbacks.
These all occur within the user's own thread.
This avoids the need for any mutex locking when dealing with ACAI objects and/or data.
If that data is passed on to any third party threads, then you will need to manage that.

All ACAI applications must have some sort of event loop.
The event loop should must contain a small delay, very much application dependent,
but typically 20mS to 50mS, e.g.:
<pre>
  <b>while</b> (true) {
     epicsThreadSleep (0.02);  // 20mSec
     ACAI::Client::poll ();    // ACAI call back functions invoked from here
     ...
     ... any other application functionality
     ...
  }
</pre>

If the application provides some means to break out of event loop then the following
should be called to tidyup. This may be particularly important if leaving the event
loop does not occur immediatlry before the application terminates.
<pre>
   pv.closeChannel();
   ACAI::Client::finalise();
</pre>

The above is fine, but we need to access the PV's data for this program to do
anything useful. ACAI provides a number of ways to gain access to PV data.
These are:

a) within the event loop, just read the data, if available, out of the client object;
<pre>
     <b>if</b> (pv.dataIsAvailable()) {
        double x = pv.getFloating ();
        // do something with x
     }
 

</pre>


b) define and setup a connection and/or data update handler, e.g.
<pre>

  <b>static void</b> dataUpdateEventHandler (ACAI::Client* client, <b>const</b> bool firstupdate)
  {
     double x = client->getFloating ();
     // do something with latest client data
  }

  ...

  pv.setUpdateHandler (dataUpdateEventHandler);


</pre>

c) derive a class based on ACAI::Client and override the ACAI::Client::connectionUpdate
or ACAI::Client::dataUpdate functions;

<pre>
  <b>class</b> MyClient : <b>public</b> ACAI::Client {

     // override base class function
     <b>void</b> connectionUpdate (<b>const</b> bool isConnected) {
        double x = this->getFloating ();
        // do something with latest client data
     }
  }

  ...

  MyClient pv ("SR11MCM01:CURRENT_MONITOR");


</pre>

d) use an ACAI::Abstract_Client_User class - refer to class documentation.


<h3>Example</h3>
An example program that brings all the above together has been included in
acaiTestApp/acai_monitor.cpp
The is a simple command line program that use the ACAI framework.
This programs mimics the basic fuctionality of the EPICS base program camonitor.

Note:
This program is intended as example (and test) ACAI program rather than as
replacements for the afore mentioned camonitor program.


<h2>Building/Linking</h2>
An ACAI program, like the above example, may be built using the EPICS make system.
However, as the ACAI header files only call up other ACAI header files the fallowing
external header files:
<pre>
  \#include \<set\>
  \#include \<string\>
  \#include \<vector\>
</pre>
it is easy to build an ACAI application without any reference to EPICS header files.


<h2>Dependancies</h2>
Apart from the EPICS shared libraries ca, Com and their dependancies, ACAI does
not reply on any non-standard libraries and/or templates, thus there are no troublesome
or unexpected dependancies.

*/
